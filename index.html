<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Game - Chase the Target</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body class="game-running">
<div class="instructions">Cat Game: Watch the target move! Press 'S' for settings, Spacebar to pause</div>
<div class="game-status" id="gameStatus">Game Running</div>

<div class="pause-overlay" id="pauseOverlay">
    ‚è∏Ô∏è PAUSED
    <div class="sub-text">Press Spacebar to resume</div>
</div>

<button class="settings-toggle" onclick="toggleSettings()">‚öôÔ∏è Settings</button>

<div class="settings-panel" id="settingsPanel">
    <div class="setting-group">
        <label for="objectType">Chase Target:</label>
        <select id="objectType" onchange="updateObjectType(this.value)">
            <option value="dot">Red Dot</option>
            <option value="mouse">Mouse</option>
            <option value="worm">Worm (Physics)</option>
        </select>
    </div>

    <div class="setting-group">
        <label for="speed">Movement Speed:</label>
        <input type="range" id="speed" min="500" max="5000" value="2000" oninput="updateSpeed(this.value)">
        <div class="value-display" id="speedDisplay">2.0s</div>
    </div>

    <div class="setting-group">
        <label for="movementType">Movement Type:</label>
        <select id="movementType" onchange="updateMovementType(this.value)">
            <option value="random">Random</option>
            <option value="circular">Circular</option>
            <option value="zigzag">Zigzag</option>
            <option value="edges">Edge Bouncing</option>
            <option value="spiral">Spiral</option>
            <option value="mouse">Touch/Mouse Control</option>
        </select>
    </div>

    <div class="setting-group">
        <label for="targetSize">Target Size:</label>
        <input type="range" id="targetSize" min="15" max="80" value="25" oninput="updateTargetSize(this.value)">
        <div class="value-display" id="sizeDisplay">25px</div>
    </div>

    <div class="setting-group">
        <label for="targetColor">Target Color:</label>
        <input type="color" id="targetColor" value="#ff0000" onchange="updateTargetColor(this.value)">
    </div>

    <div class="setting-group">
        <label for="wormLength">Worm Length:</label>
        <input type="range" id="wormLength" min="3" max="15" value="8" oninput="updateWormLength(this.value)">
        <div class="value-display" id="lengthDisplay">8 segments</div>
    </div>

    <div class="setting-group">
        <label for="animationSpeed">Animation Speed:</label>
        <input type="range" id="animationSpeed" min="0.1" max="3" step="0.1" value="0.8" oninput="updateAnimationSpeed(this.value)">
        <div class="value-display" id="animationDisplay">0.8s</div>
    </div>
</div>

<div id="chase-target" class="target-dot"></div>

<script>
    const chaseTarget = document.getElementById('chase-target');
    const gameStatus = document.getElementById('gameStatus');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const settingsPanel = document.getElementById('settingsPanel');

    let isMoving = true;
    let moveTimeout;
    let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Settings with mobile-friendly defaults
    let settings = {
        objectType: 'dot',
        speed: 2000,
        movementType: 'random',
        targetSize: isMobileDevice ? 35 : 25, // Larger default for mobile
        targetColor: '#ff0000',
        wormLength: 8,
        animationSpeed: 0.8
    };

    // Movement patterns
    let circularAngle = 0;
    let zigzagDirection = 1;
    let spiralRadius = 50;
    let spiralAngle = 0;
    let edgePosition = { x: 0, y: 0, direction: { x: 1, y: 1 } };

    // Worm physics
    let wormSegments = [];
    let wormTarget = { x: 0, y: 0 };
    let wormJiggleTimer = 0;
    let wormIsJiggling = false;
    let wormJiggleIntensity = 0;

    // Touch/Mouse control
    let inputPosition = { x: 0, y: 0 };

    function updateCursorVisibility() {
        const body = document.body;
        const isSettingsOpen = settingsPanel.classList.contains('visible');
        const isMouseControl = settings.movementType === 'mouse';

        if (isMoving && !isSettingsOpen) {
            body.className = 'game-running';
            if (isMouseControl) {
                gameStatus.textContent = isMobileDevice ? 'Touch Control Active' : 'Mouse Control Active';
            } else {
                gameStatus.textContent = 'Game Running';
            }
            pauseOverlay.classList.remove('visible');
        } else {
            body.className = 'game-paused';
            gameStatus.textContent = isSettingsOpen ? 'Settings Open' : 'Game Paused';

            if (!isSettingsOpen) {
                pauseOverlay.classList.add('visible');
            } else {
                pauseOverlay.classList.remove('visible');
            }
        }
    }

    function toggleSettings() {
        settingsPanel.classList.toggle('visible');
        updateCursorVisibility();
    }

    function updateObjectType(type) {
        settings.objectType = type;
        chaseTarget.className = `target-${type}`;

        if (type === 'worm') {
            initializeWorm();
            chaseTarget.style.display = 'none';
        } else {
            clearWormSegments();
            chaseTarget.style.display = 'block';
        }

        updateTargetAppearance();
        updateTransitionMode();
        restartMovement();
    }

    function updateSpeed(value) {
        settings.speed = parseInt(value);
        document.getElementById('speedDisplay').textContent = (value / 1000).toFixed(1) + 's';
        restartMovement();
    }

    function updateMovementType(type) {
        settings.movementType = type;
        updateCursorVisibility();
        updateTransitionMode();
        restartMovement();
    }

    function updateTargetSize(size) {
        settings.targetSize = parseInt(size);
        chaseTarget.style.width = size + 'px';
        chaseTarget.style.height = size + 'px';
        document.getElementById('sizeDisplay').textContent = size + 'px';

        if (settings.objectType === 'mouse') {
            chaseTarget.style.fontSize = size + 'px';
            chaseTarget.style.lineHeight = size + 'px';
        }

        if (settings.objectType === 'worm') {
            updateWormSize();
        }
    }

    function updateTargetColor(color) {
        settings.targetColor = color;
        updateTargetAppearance();
    }

    function updateWormLength(length) {
        settings.wormLength = parseInt(length);
        document.getElementById('lengthDisplay').textContent = length + ' segments';

        if (settings.objectType === 'worm') {
            initializeWorm();
        }
    }

    function updateAnimationSpeed(speed) {
        settings.animationSpeed = parseFloat(speed);
        updateTransitionMode();
        document.getElementById('animationDisplay').textContent = speed + 's';
    }

    function updateTransitionMode() {
        if (settings.movementType === 'mouse') {
            chaseTarget.style.transition = 'none';
        } else {
            chaseTarget.style.transition = `all ${settings.animationSpeed}s ease-in-out`;
        }
    }

    function updateTargetAppearance() {
        switch (settings.objectType) {
            case 'dot':
                chaseTarget.style.backgroundColor = settings.targetColor;
                chaseTarget.style.boxShadow = `0 0 15px ${settings.targetColor}`;
                chaseTarget.innerHTML = '';
                chaseTarget.style.fontSize = '';
                chaseTarget.style.lineHeight = '';
                break;
            case 'mouse':
                chaseTarget.style.backgroundColor = 'transparent';
                chaseTarget.style.boxShadow = 'none';
                chaseTarget.innerHTML = 'üê≠';
                chaseTarget.style.fontSize = settings.targetSize + 'px';
                chaseTarget.style.lineHeight = settings.targetSize + 'px';
                break;
            case 'worm':
                break;
        }
    }

    function initializeWorm() {
        clearWormSegments();
        const segmentCount = settings.wormLength;
        const startX = Math.random() * (window.innerWidth - 200) + 100;
        const startY = Math.random() * (window.innerHeight - 200) + 100;

        for (let i = 0; i < segmentCount; i++) {
            const segment = document.createElement('div');
            segment.className = 'worm-segment';
            const segmentSize = settings.targetSize * (1 - (i * 0.08));
            segment.style.width = segmentSize + 'px';
            segment.style.height = segmentSize + 'px';
            segment.style.backgroundColor = settings.targetColor;
            segment.style.position = 'absolute';
            segment.style.borderRadius = '50%';
            segment.style.opacity = (1 - (i * 0.06)).toString();
            segment.style.boxShadow = i === 0 ? `0 0 10px ${settings.targetColor}` : 'none';
            document.body.appendChild(segment);

            wormSegments.push({
                element: segment,
                x: startX - (i * 12),
                y: startY,
                targetX: startX - (i * 12),
                targetY: startY,
                jiggleX: 0,
                jiggleY: 0
            });
        }

        wormTarget.x = startX;
        wormTarget.y = startY;
    }

    function clearWormSegments() {
        wormSegments.forEach(segment => {
            if (segment.element && segment.element.parentNode) {
                segment.element.parentNode.removeChild(segment.element);
            }
        });
        wormSegments = [];
    }

    function updateWormSize() {
        wormSegments.forEach((segment, i) => {
            const segmentSize = settings.targetSize * (1 - (i * 0.08));
            segment.element.style.width = segmentSize + 'px';
            segment.element.style.height = segmentSize + 'px';
        });
    }

    function updateWormPhysics() {
        if (wormSegments.length === 0) return;

        const springStrength = 0.15;
        const damping = 0.8;
        const segmentDistance = 12;

        for (let i = wormSegments.length - 1; i >= 0; i--) {
            const segment = wormSegments[i];

            if (i === 0) {
                const headSpring = 0.08;
                segment.targetX = wormTarget.x + (Math.random() - 0.5) * wormJiggleIntensity;
                segment.targetY = wormTarget.y + (Math.random() - 0.5) * wormJiggleIntensity;

                segment.x += (segment.targetX - segment.x) * headSpring;
                segment.y += (segment.targetY - segment.y) * headSpring;
            } else {
                const prevSegment = wormSegments[i - 1];
                const distance = Math.sqrt((segment.x - prevSegment.x) ** 2 + (segment.y - prevSegment.y) ** 2);

                if (distance > segmentDistance) {
                    const angle = Math.atan2(segment.y - prevSegment.y, segment.x - prevSegment.x);
                    segment.targetX = prevSegment.x + Math.cos(angle) * segmentDistance;
                    segment.targetY = prevSegment.y + Math.sin(angle) * segmentDistance;
                }

                segment.x += (segment.targetX - segment.x) * springStrength;
                segment.y += (segment.targetY - segment.y) * springStrength;

                segment.x *= damping;
                segment.y *= damping;
            }

            if (wormIsJiggling) {
                segment.jiggleX = (Math.random() - 0.5) * wormJiggleIntensity * 0.3;
                segment.jiggleY = (Math.random() - 0.5) * wormJiggleIntensity * 0.3;
            } else {
                segment.jiggleX *= 0.9;
                segment.jiggleY *= 0.9;
            }

            segment.element.style.left = (segment.x + segment.jiggleX) + 'px';
            segment.element.style.top = (segment.y + segment.jiggleY) + 'px';
            segment.element.style.backgroundColor = settings.targetColor;
        }

        if (wormIsJiggling) {
            wormJiggleTimer--;
            if (wormJiggleTimer <= 0) {
                wormIsJiggling = false;
                wormJiggleIntensity = 0;
            }
        }
    }

    function startWormJiggle() {
        wormIsJiggling = true;
        wormJiggleTimer = 60;
        wormJiggleIntensity = 15;
    }

    function getRandomPosition() {
        const margin = settings.targetSize;
        return {
            x: Math.random() * (window.innerWidth - margin * 2) + margin,
            y: Math.random() * (window.innerHeight - margin * 2) + margin
        };
    }

    function getCircularPosition() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const radius = Math.min(centerX, centerY) * 0.7;

        circularAngle += 0.1;

        return {
            x: centerX + Math.cos(circularAngle) * radius - settings.targetSize / 2,
            y: centerY + Math.sin(circularAngle) * radius - settings.targetSize / 2
        };
    }

    function getZigzagPosition() {
        const centerX = window.innerWidth / 2;
        const amplitude = window.innerWidth * 0.3;

        zigzagDirection += 0.2;

        return {
            x: centerX + Math.sin(zigzagDirection) * amplitude - settings.targetSize / 2,
            y: 50 + (zigzagDirection * 30) % (window.innerHeight - 100)
        };
    }

    function getEdgePosition() {
        const margin = settings.targetSize;
        const maxX = window.innerWidth - margin;
        const maxY = window.innerHeight - margin;

        edgePosition.x += edgePosition.direction.x * 3;
        edgePosition.y += edgePosition.direction.y * 3;

        if (edgePosition.x <= 0 || edgePosition.x >= maxX) {
            edgePosition.direction.x *= -1;
            edgePosition.x = Math.max(0, Math.min(maxX, edgePosition.x));
        }

        if (edgePosition.y <= 0 || edgePosition.y >= maxY) {
            edgePosition.direction.y *= -1;
            edgePosition.y = Math.max(0, Math.min(maxY, edgePosition.y));
        }

        return { x: edgePosition.x, y: edgePosition.y };
    }

    function getSpiralPosition() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;

        spiralAngle += 0.5;
        spiralRadius += 2;

        if (spiralRadius > Math.min(centerX, centerY)) {
            spiralRadius = 50;
        }

        const x = centerX + Math.cos(spiralAngle) * spiralRadius - settings.targetSize / 2;
        const y = centerY + Math.sin(spiralAngle) * spiralRadius - settings.targetSize / 2;

        return {
            x: Math.max(0, Math.min(x, window.innerWidth - settings.targetSize)),
            y: Math.max(0, Math.min(y, window.innerHeight - settings.targetSize))
        };
    }

    function getInputPosition() {
        return {
            x: inputPosition.x - settings.targetSize / 2,
            y: inputPosition.y - settings.targetSize / 2
        };
    }

    function getPositionByType() {
        switch (settings.movementType) {
            case 'circular': return getCircularPosition();
            case 'zigzag': return getZigzagPosition();
            case 'edges': return getEdgePosition();
            case 'spiral': return getSpiralPosition();
            case 'mouse': return getInputPosition();
            default: return getRandomPosition();
        }
    }

    function moveTarget() {
        if (isMoving) {
            const position = getPositionByType();

            if (settings.objectType === 'worm') {
                wormTarget.x = position.x;
                wormTarget.y = position.y;
                if (settings.movementType !== 'mouse') {
                    startWormJiggle();
                }
            } else {
                chaseTarget.style.left = position.x + 'px';
                chaseTarget.style.top = position.y + 'px';
            }
        }
    }

    function scheduleNextMove() {
        if (moveTimeout) clearTimeout(moveTimeout);

        if (settings.movementType === 'mouse') {
            return;
        }

        const baseDelay = settings.movementType === 'random' ?
            Math.random() * (settings.speed - 1000) + 1000 :
            settings.speed / 3;

        const delay = settings.objectType === 'worm' ? baseDelay + 1000 : baseDelay;

        moveTimeout = setTimeout(() => {
            moveTarget();
            scheduleNextMove();
        }, delay);
    }

    function restartMovement() {
        if (moveTimeout) clearTimeout(moveTimeout);
        if (isMoving) {
            if (settings.movementType === 'mouse') {
                moveTarget();
            } else {
                moveTarget();
                scheduleNextMove();
            }
        }
    }

    function togglePause() {
        isMoving = !isMoving;
        if (isMoving) {
            if (settings.movementType !== 'mouse') {
                scheduleNextMove();
            }
        }
        updateCursorVisibility();
    }

    function wormAnimationLoop() {
        if (settings.objectType === 'worm') {
            updateWormPhysics();
        }
        requestAnimationFrame(wormAnimationLoop);
    }

    function inputControlLoop() {
        if (settings.movementType === 'mouse' && isMoving) {
            moveTarget();
        }
        requestAnimationFrame(inputControlLoop);
    }

    // Initialize mobile defaults
    if (isMobileDevice) {
        document.getElementById('targetSize').value = settings.targetSize;
        document.getElementById('sizeDisplay').textContent = settings.targetSize + 'px';
        updateTargetSize(settings.targetSize);
    }

    // Start the game
    moveTarget();
    scheduleNextMove();
    updateCursorVisibility();
    updateTargetAppearance();
    updateTransitionMode();
    wormAnimationLoop();
    inputControlLoop();

    // Event listeners
    document.addEventListener('keydown', (event) => {
        if (event.code === 'Space') {
            togglePause();
            event.preventDefault();
        } else if (event.code === 'KeyS') {
            toggleSettings();
            event.preventDefault();
        }
    });

    // Mouse control event listener
    document.addEventListener('mousemove', (event) => {
        inputPosition.x = event.clientX;
        inputPosition.y = event.clientY;
    });

    // Touch control event listeners
    document.addEventListener('touchstart', (event) => {
        event.preventDefault();
        if (event.touches.length > 0) {
            inputPosition.x = event.touches[0].clientX;
            inputPosition.y = event.touches[0].clientY;
        }
    }, { passive: false });

    document.addEventListener('touchmove', (event) => {
        event.preventDefault();
        if (event.touches.length > 0) {
            inputPosition.x = event.touches[0].clientX;
            inputPosition.y = event.touches[0].clientY;
        }
    }, { passive: false });

    document.addEventListener('touchend', (event) => {
        event.preventDefault();
    }, { passive: false });

    // Prevent scrolling and zooming on mobile
    document.addEventListener('gesturestart', (event) => {
        event.preventDefault();
    });

    document.addEventListener('gesturechange', (event) => {
        event.preventDefault();
    });

    document.addEventListener('gestureend', (event) => {
        event.preventDefault();
    });

    window.addEventListener('resize', () => {
        if (isMoving) {
            moveTarget();
        }
    });

    // Initialize edge position
    edgePosition.x = Math.random() * (window.innerWidth - settings.targetSize);
    edgePosition.y = Math.random() * (window.innerHeight - settings.targetSize);

    // Click/Touch anywhere to resume when paused
    document.addEventListener('click', (event) => {
        if (!isMoving && !settingsPanel.contains(event.target) &&
            !event.target.classList.contains('settings-toggle')) {
            togglePause();
        }
    });

    // Touch to resume (for mobile)
    document.addEventListener('touchstart', (event) => {
        if (!isMoving && !settingsPanel.contains(event.target) &&
            !event.target.classList.contains('settings-toggle')) {
            togglePause();
        }
    });
</script>
</body>
</html>