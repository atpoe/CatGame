<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Game - Chase the Target</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body class="game-running">
<div class="instructions">Cat Game: Watch the target move! Press 'S' for settings, Spacebar to pause</div>
<div class="game-status" id="gameStatus">Game Running</div>

<div class="pause-overlay" id="pauseOverlay">
    ‚è∏Ô∏è PAUSED
    <div class="sub-text">Press Spacebar to resume</div>
</div>

<button class="settings-toggle" onclick="toggleSettings()">‚öôÔ∏è Settings</button>

<div class="settings-panel" id="settingsPanel">
    <div class="setting-group">
        <label for="targetCount">Number of Targets:</label>
        <input type="range" id="targetCount" min="1" max="8" value="1" oninput="updateTargetCount(this.value)">
        <div class="value-display" id="countDisplay">1 target</div>
    </div>

    <div class="setting-group">
        <label for="objectType">Object Type:</label>
        <select id="objectType" onchange="updateObjectType(this.value)">
            <option value="dot">Red Dot</option>
            <option value="mouse">Mouse üê≠</option>
            <option value="worm">Worm</option>
        </select>
    </div>

    <div class="setting-group">
        <label for="speed">Movement Speed:</label>
        <input type="range" id="speed" min="500" max="5000" step="100" value="2000" oninput="updateSpeed(this.value)">
        <div class="value-display" id="speedDisplay">2.0s</div>
    </div>

    <div class="setting-group">
        <label for="idleTime">Idle Time:</label>
        <input type="range" id="idleTime" min="0" max="3000" step="100" value="1000" oninput="updateIdleTime(this.value)">
        <div class="value-display" id="idleDisplay">1.0s</div>
    </div>

    <div class="setting-group">
        <label for="movementType">Movement Pattern:</label>
        <select id="movementType" onchange="updateMovementType(this.value)">
            <option value="random">Random</option>
            <option value="circular">Orbital Motion</option>
            <option value="zigzag">Wave Scanner</option>
            <option value="edges">Perimeter Patrol</option>
            <option value="spiral">Dynamic Spiral</option>
            <option value="mouse">Mouse Control</option>
        </select>
    </div>

    <div class="setting-group">
        <label for="targetSize">Target Size:</label>
        <input type="range" id="targetSize" min="10" max="60" value="20" oninput="updateTargetSize(this.value)">
        <div class="value-display" id="sizeDisplay">20px</div>
    </div>

    <div class="setting-group">
        <label for="targetColor">Target Color:</label>
        <input type="color" id="targetColor" value="#ff0000" oninput="updateTargetColor(this.value)">
    </div>

    <div class="setting-group worm-only">
        <label for="wormLength">Worm Length:</label>
        <input type="range" id="wormLength" min="3" max="20" value="8" oninput="updateWormLength(this.value)">
        <div class="value-display" id="lengthDisplay">8 segments</div>
    </div>
</div>

<script>
    const gameStatus = document.getElementById('gameStatus');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const settingsPanel = document.getElementById('settingsPanel');

    let isMoving = true;
    let targets = [];
    let animationFrameId = null;
    let startTime = Date.now();
    let randomMoveTimeouts = [];

    // Settings
    let settings = {
        targetCount: 1,
        objectType: 'dot',
        speed: 2000,
        idleTime: 1000,
        movementType: 'random',
        targetSize: 20,
        targetColor: '#ff0000',
        wormLength: 8,
        animationSpeed: 0.8
    };

    // Movement patterns (per target)
    let targetStates = [];

    // Mouse control
    let mousePosition = { x: 0, y: 0 };

    function initializeTargetStates() {
        while (targetStates.length < settings.targetCount) {
            const index = targetStates.length;
            targetStates.push({
                // Orbital motion - full screen
                orbitRadius: 50 + Math.random() * 150,
                orbitSpeed: 0.0003 + (index * 0.0001),
                orbitCenterX: Math.random() * window.innerWidth,
                orbitCenterY: Math.random() * window.innerHeight,
                orbitCenterSpeedX: (Math.random() - 0.5) * 0.5,
                orbitCenterSpeedY: (Math.random() - 0.5) * 0.5,

                // Wave scanner - slower movement
                scanDirection: index % 2 === 0 ? 1 : -1,
                wavePhase: index * Math.PI / 2,
                scanSpeed: 0.0003 + (index * 0.0001),
                scanCenterY: Math.random() * window.innerHeight,
                scanAmplitude: 50 + Math.random() * 100,

                // Perimeter patrol
                perimeterProgress: (index / settings.targetCount) * 2 * Math.PI,
                perimeterSpeed: 0.0008 + (index * 0.0002),
                perimeterDirection: index % 2 === 0 ? 1 : -1,

                // Dynamic spiral - full screen
                spiralAngle: index * Math.PI / 2,
                spiralRadius: 30 + (index * 15),
                spiralDirection: 1,
                spiralSpeed: 0.001 + (index * 0.0003),
                spiralRadiusSpeed: 0.3,
                spiralCenterX: Math.random() * window.innerWidth,
                spiralCenterY: Math.random() * window.innerHeight,
                spiralCenterSpeedX: (Math.random() - 0.5) * 0.3,
                spiralCenterSpeedY: (Math.random() - 0.5) * 0.3,

                // Worm data
                wormSegments: [],
                wormTarget: { x: 0, y: 0 },
                wormJiggleTimer: 0,
                wormIsJiggling: false,
                wormJiggleIntensity: 0
            });
        }
    }

    function createTarget(index) {
        const target = document.createElement('div');
        target.id = `target-${index}`;
        target.className = `target-${settings.objectType}`;
        target.style.position = 'absolute';
        target.style.width = settings.targetSize + 'px';
        target.style.height = settings.targetSize + 'px';
        target.style.borderRadius = '50%';
        target.style.left = Math.random() * (window.innerWidth - settings.targetSize) + 'px';
        target.style.top = Math.random() * (window.innerHeight - settings.targetSize) + 'px';
        target.style.transition = 'none';
        document.body.appendChild(target);
        return target;
    }

    function updateTargetCount(count) {
        settings.targetCount = parseInt(count);
        document.getElementById('countDisplay').textContent = count + (count === '1' ? ' target' : ' targets');

        clearAllTargets();
        initializeTargetStates();

        for (let i = 0; i < settings.targetCount; i++) {
            const target = createTarget(i);
            targets.push(target);

            if (settings.objectType === 'worm') {
                initializeWorm(i);
                target.style.display = 'none';
            }
        }

        updateAllTargetAppearance();
        updateTransitionModes();
        restartAnimation();
    }

    function clearAllTargets() {
        targets.forEach(target => {
            if (target.parentNode) {
                target.parentNode.removeChild(target);
            }
        });
        targets = [];

        targetStates.forEach(state => clearWormSegments(state));
    }

    function clearWormSegments(state) {
        if (state.wormSegments) {
            state.wormSegments.forEach(segment => {
                if (segment.element && segment.element.parentNode) {
                    segment.element.parentNode.removeChild(segment.element);
                }
            });
            state.wormSegments = [];
        }
    }

    function updateAllTargetAppearance() {
        targets.forEach((target, i) => {
            if (settings.objectType === 'mouse') {
                target.textContent = 'üê≠';
                target.style.fontSize = settings.targetSize + 'px';
                target.style.lineHeight = settings.targetSize + 'px';
                target.style.textAlign = 'center';
                target.style.backgroundColor = 'transparent';
            } else if (settings.objectType === 'dot') {
                target.textContent = '';
                target.style.backgroundColor = settings.targetColor;
            }
        });
    }

    function updateTransitionModes() {
        targets.forEach((target, i) => {
            if (settings.movementType === 'random') {
                const transitionDuration = (settings.speed / 1000).toFixed(1);
                target.style.transition = `all ${transitionDuration}s ease-in-out`;
            } else {
                target.style.transition = 'none';
            }
        });
    }

    function updateCursorVisibility() {
        const body = document.body;
        const isSettingsOpen = settingsPanel.classList.contains('visible');
        const isMouseControl = settings.movementType === 'mouse';

        if (isMoving && !isSettingsOpen) {
            body.className = 'game-running';
            if (isMouseControl) {
                gameStatus.textContent = 'Mouse Control Active';
            } else {
                gameStatus.textContent = 'Game Running';
            }
            pauseOverlay.classList.remove('visible');
        } else {
            body.className = 'game-paused';
            gameStatus.textContent = isSettingsOpen ? 'Settings Open' : 'Game Paused';

            if (!isSettingsOpen) {
                pauseOverlay.classList.add('visible');
            } else {
                pauseOverlay.classList.remove('visible');
            }
        }
    }

    function toggleSettings() {
        settingsPanel.classList.toggle('visible');
        updateCursorVisibility();
    }

    function updateObjectType(type) {
        settings.objectType = type;

        targetStates.forEach(state => clearWormSegments(state));

        targets.forEach((target, i) => {
            target.className = `target-${type}`;
            if (type === 'worm') {
                initializeWorm(i);
                target.style.display = 'none';
            } else {
                target.style.display = 'block';
            }
        });

        updateAllTargetAppearance();
        updateTransitionModes();
        restartAnimation();
    }

    function updateSpeed(value) {
        settings.speed = parseInt(value);
        document.getElementById('speedDisplay').textContent = (value / 1000).toFixed(1) + 's';

        updateTransitionModes();

        const speedMultiplier = 2000 / settings.speed;
        targetStates.forEach((state, index) => {
            state.orbitSpeed = (0.0003 + (index * 0.0001)) * speedMultiplier;
            state.scanSpeed = (0.0003 + (index * 0.0001)) * speedMultiplier;
            state.perimeterSpeed = (0.0008 + (index * 0.0002)) * speedMultiplier;
            state.spiralSpeed = (0.001 + (index * 0.0003)) * speedMultiplier;
        });

        if (settings.movementType === 'random') {
            restartRandomMovement();
        }
    }

    function updateIdleTime(value) {
        settings.idleTime = parseInt(value);
        document.getElementById('idleDisplay').textContent = (value / 1000).toFixed(1) + 's';

        if (settings.movementType === 'random') {
            restartRandomMovement();
        }
    }

    function updateMovementType(type) {
        settings.movementType = type;
        updateCursorVisibility();
        updateTransitionModes();

        if (type !== 'random') {
            randomMoveTimeouts.forEach(timeout => {
                if (timeout) clearTimeout(timeout);
            });
            randomMoveTimeouts = [];
        }

        restartAnimation();
    }

    function updateTargetSize(size) {
        settings.targetSize = parseInt(size);
        document.getElementById('sizeDisplay').textContent = size + 'px';

        targets.forEach(target => {
            target.style.width = size + 'px';
            target.style.height = size + 'px';

            if (settings.objectType === 'mouse') {
                target.style.fontSize = size + 'px';
                target.style.lineHeight = size + 'px';
            }
        });

        if (settings.objectType === 'worm') {
            targetStates.forEach((state, i) => initializeWorm(i));
        }
    }

    function updateTargetColor(color) {
        settings.targetColor = color;

        targets.forEach(target => {
            if (settings.objectType === 'dot') {
                target.style.backgroundColor = color;
            }
        });

        if (settings.objectType === 'worm') {
            targetStates.forEach(state => {
                if (state.wormSegments) {
                    state.wormSegments.forEach((segment, i) => {
                        segment.element.style.backgroundColor = color;
                        if (i === 0) {
                            segment.element.style.boxShadow = `0 0 10px ${color}`;
                        }
                    });
                }
            });
        }
    }

    function updateWormLength(length) {
        settings.wormLength = parseInt(length);
        document.getElementById('lengthDisplay').textContent = length + ' segments';

        if (settings.objectType === 'worm') {
            targetStates.forEach((state, i) => initializeWorm(i));
        }
    }

    // Movement pattern functions
    function scheduleRandomMovement(targetIndex) {
        if (!isMoving || settings.movementType !== 'random') return;

        const moveToNewPosition = () => {
            if (!isMoving || settings.movementType !== 'random' || !targets[targetIndex]) return;

            const target = targets[targetIndex];
            const state = targetStates[targetIndex];

            const newPosition = {
                x: Math.random() * (window.innerWidth - settings.targetSize),
                y: Math.random() * (window.innerHeight - settings.targetSize)
            };

            state.targetPos = newPosition;
            target.style.left = newPosition.x + 'px';
            target.style.top = newPosition.y + 'px';

            const nextMove = () => scheduleRandomMovement(targetIndex);
            const timeout = setTimeout(nextMove, settings.speed + settings.idleTime);
            randomMoveTimeouts[targetIndex] = timeout;
        };

        const timeout = setTimeout(moveToNewPosition, settings.idleTime);
        randomMoveTimeouts[targetIndex] = timeout;
    }

    function restartRandomMovement() {
        randomMoveTimeouts.forEach(timeout => {
            if (timeout) clearTimeout(timeout);
        });
        randomMoveTimeouts = [];

        if (settings.movementType === 'random') {
            for (let i = 0; i < targets.length; i++) {
                scheduleRandomMovement(i);
            }
        }
    }

    function getOrbitalPosition(state, currentTime) {
        state.orbitCenterX += state.orbitCenterSpeedX;
        state.orbitCenterY += state.orbitCenterSpeedY;

        const margin = state.orbitRadius + settings.targetSize;
        if (state.orbitCenterX < margin || state.orbitCenterX > window.innerWidth - margin) {
            state.orbitCenterSpeedX *= -1;
            state.orbitCenterX = Math.max(margin, Math.min(state.orbitCenterX, window.innerWidth - margin));
        }
        if (state.orbitCenterY < margin || state.orbitCenterY > window.innerHeight - margin) {
            state.orbitCenterSpeedY *= -1;
            state.orbitCenterY = Math.max(margin, Math.min(state.orbitCenterY, window.innerHeight - margin));
        }

        const angle = currentTime * state.orbitSpeed;
        const x = state.orbitCenterX + Math.cos(angle) * state.orbitRadius - settings.targetSize / 2;
        const y = state.orbitCenterY + Math.sin(angle) * state.orbitRadius - settings.targetSize / 2;

        return {
            x: Math.max(0, Math.min(x, window.innerWidth - settings.targetSize)),
            y: Math.max(0, Math.min(y, window.innerHeight - settings.targetSize))
        };
    }

    function getWaveScannerPosition(state, currentTime) {
        const progress = (currentTime * state.scanSpeed) % 2;
        let xProgress;

        if (progress < 1) {
            xProgress = progress;
        } else {
            xProgress = 2 - progress;
        }

        const x = xProgress * (window.innerWidth - settings.targetSize);
        const waveY = Math.sin(currentTime * state.scanSpeed * 3 + state.wavePhase) * state.scanAmplitude * state.scanDirection;
        const y = state.scanCenterY + waveY - settings.targetSize / 2;

        return {
            x: Math.max(0, Math.min(x, window.innerWidth - settings.targetSize)),
            y: Math.max(0, Math.min(y, window.innerHeight - settings.targetSize))
        };
    }

    function getPerimeterPosition(state, currentTime) {
        state.perimeterProgress += state.perimeterSpeed * state.perimeterDirection;

        const margin = settings.targetSize / 2;
        const width = window.innerWidth - margin * 2;
        const height = window.innerHeight - margin * 2;
        const perimeter = 2 * (width + height);

        let progress = ((state.perimeterProgress % (Math.PI * 2)) / (Math.PI * 2)) * perimeter;
        if (progress < 0) progress += perimeter;

        let x, y;

        if (progress < width) {
            x = margin + progress;
            y = margin;
        } else if (progress < width + height) {
            x = margin + width;
            y = margin + (progress - width);
        } else if (progress < 2 * width + height) {
            x = margin + width - (progress - width - height);
            y = margin + height;
        } else {
            x = margin;
            y = margin + height - (progress - 2 * width - height);
        }

        return {
            x: Math.max(0, Math.min(x - settings.targetSize / 2, window.innerWidth - settings.targetSize)),
            y: Math.max(0, Math.min(y - settings.targetSize / 2, window.innerHeight - settings.targetSize))
        };
    }

    function getDynamicSpiralPosition(state, currentTime) {
        state.spiralCenterX += state.spiralCenterSpeedX;
        state.spiralCenterY += state.spiralCenterSpeedY;

        const maxRadius = Math.min(window.innerWidth, window.innerHeight) * 0.3;
        const margin = maxRadius + settings.targetSize;

        if (state.spiralCenterX < margin || state.spiralCenterX > window.innerWidth - margin) {
            state.spiralCenterSpeedX *= -1;
            state.spiralCenterX = Math.max(margin, Math.min(state.spiralCenterX, window.innerWidth - margin));
        }
        if (state.spiralCenterY < margin || state.spiralCenterY > window.innerHeight - margin) {
            state.spiralCenterSpeedY *= -1;
            state.spiralCenterY = Math.max(margin, Math.min(state.spiralCenterY, window.innerHeight - margin));
        }

        state.spiralAngle += state.spiralSpeed;
        state.spiralRadius += state.spiralRadiusSpeed * state.spiralDirection;

        const minRadius = 20;
        if (state.spiralRadius > maxRadius || state.spiralRadius < minRadius) {
            state.spiralDirection *= -1;
            state.spiralRadius = Math.max(minRadius, Math.min(maxRadius, state.spiralRadius));
        }

        const x = state.spiralCenterX + Math.cos(state.spiralAngle) * state.spiralRadius - settings.targetSize / 2;
        const y = state.spiralCenterY + Math.sin(state.spiralAngle) * state.spiralRadius - settings.targetSize / 2;

        return {
            x: Math.max(0, Math.min(x, window.innerWidth - settings.targetSize)),
            y: Math.max(0, Math.min(y, window.innerHeight - settings.targetSize))
        };
    }

    function animate() {
        if (!isMoving) {
            animationFrameId = requestAnimationFrame(animate);
            return;
        }

        const currentTime = Date.now() - startTime;

        if (settings.movementType !== 'random') {
            targets.forEach((target, i) => {
                const state = targetStates[i];
                let newPosition;

                switch (settings.movementType) {
                    case 'circular':
                        newPosition = getOrbitalPosition(state, currentTime);
                        break;
                    case 'zigzag':
                        newPosition = getWaveScannerPosition(state, currentTime);
                        break;
                    case 'edges':
                        newPosition = getPerimeterPosition(state, currentTime);
                        break;
                    case 'spiral':
                        newPosition = getDynamicSpiralPosition(state, currentTime);
                        break;
                    case 'mouse':
                        newPosition = {
                            x: mousePosition.x - settings.targetSize/2,
                            y: mousePosition.y - settings.targetSize/2
                        };
                        break;
                    default:
                        return;
                }

                if (settings.objectType === 'worm') {
                    state.wormTarget = newPosition;
                    if (Math.abs(state.wormTarget.x - state.wormSegments[0]?.x) > 5 ||
                        Math.abs(state.wormTarget.y - state.wormSegments[0]?.y) > 5) {
                        startWormJiggle(state);
                    }
                } else {
                    target.style.left = newPosition.x + 'px';
                    target.style.top = newPosition.y + 'px';
                }
            });
        }

        if (settings.objectType === 'worm') {
            targetStates.forEach(state => updateWormPhysics(state));
        }

        animationFrameId = requestAnimationFrame(animate);
    }

    function restartAnimation() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }

        startTime = Date.now();

        if (settings.movementType === 'random') {
            restartRandomMovement();
        } else {
            animate();
        }
    }

    // Worm functions
    function initializeWorm(targetIndex) {
        const state = targetStates[targetIndex];
        clearWormSegments(state);

        state.wormSegments = [];
        for (let i = 0; i < settings.wormLength; i++) {
            const segment = document.createElement('div');
            segment.className = 'worm-segment';
            segment.style.position = 'absolute';
            const segmentSize = settings.targetSize * (1 - (i * 0.08));
            segment.style.width = segmentSize + 'px';
            segment.style.height = segmentSize + 'px';
            segment.style.borderRadius = '50%';
            segment.style.backgroundColor = settings.targetColor;
            segment.style.boxShadow = i === 0 ? `0 0 10px ${settings.targetColor}` : 'none';
            document.body.appendChild(segment);

            state.wormSegments.push({
                element: segment,
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight
            });
        }
    }

    function startWormJiggle(state) {
        state.wormIsJiggling = true;
        state.wormJiggleTimer = Date.now();
        state.wormJiggleIntensity = 3;
    }

    function updateWormPhysics(state) {
        if (!state.wormSegments || state.wormSegments.length === 0) return;

        const head = state.wormSegments[0];
        const targetX = state.wormTarget.x + settings.targetSize / 2;
        const targetY = state.wormTarget.y + settings.targetSize / 2;

        const dx = targetX - head.x;
        const dy = targetY - head.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 2) {
            const speed = 0.05;
            head.x += dx * speed;
            head.y += dy * speed;
        }

        for (let i = 1; i < state.wormSegments.length; i++) {
            const segment = state.wormSegments[i];
            const prevSegment = state.wormSegments[i - 1];

            const segmentDistance = settings.targetSize * 0.7;
            const dx = prevSegment.x - segment.x;
            const dy = prevSegment.y - segment.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > segmentDistance) {
                const angle = Math.atan2(dy, dx);
                segment.x = prevSegment.x - Math.cos(angle) * segmentDistance;
                segment.y = prevSegment.y - Math.sin(angle) * segmentDistance;
            }
        }

        if (state.wormIsJiggling) {
            const elapsed = Date.now() - state.wormJiggleTimer;
            if (elapsed < 200) {
                state.wormSegments.forEach((segment, i) => {
                    const jiggle = Math.sin(elapsed * 0.1 + i) * state.wormJiggleIntensity;
                    segment.element.style.left = (segment.x + jiggle - settings.targetSize * (1 - (i * 0.08)) / 2) + 'px';
                    segment.element.style.top = (segment.y + jiggle - settings.targetSize * (1 - (i * 0.08)) / 2) + 'px';
                });
            } else {
                state.wormIsJiggling = false;
            }
        }

        if (!state.wormIsJiggling) {
            state.wormSegments.forEach((segment, i) => {
                const segmentSize = settings.targetSize * (1 - (i * 0.08));
                segment.element.style.left = (segment.x - segmentSize / 2) + 'px';
                segment.element.style.top = (segment.y - segmentSize / 2) + 'px';
            });
        }
    }

    // Event listeners
    document.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            e.preventDefault();
            isMoving = !isMoving;
            updateCursorVisibility();
            if (isMoving) {
                restartAnimation();
            }
        }
        if (e.code === 'KeyS') {
            toggleSettings();
        }
    });

    document.addEventListener('mousemove', function(e) {
        mousePosition.x = e.clientX;
        mousePosition.y = e.clientY;
    });

    document.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            mousePosition.x = e.touches[0].clientX;
            mousePosition.y = e.touches[0].clientY;
        }
    }, { passive: false });

    window.addEventListener('resize', function() {
        initializeTargetStates();
    });

    // Initialize
    initializeTargetStates();
    updateTargetCount(1);
    restartAnimation();
</script>
</body>
</html>