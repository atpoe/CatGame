<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Game</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body class="game-running">
<div class="instructions">Cat Game: Watch the target move! Press 'S' for settings, Spacebar to pause</div>
<div class="game-status" id="gameStatus">Game Running</div>

<div class="pause-overlay" id="pauseOverlay">
    PAUSED
</div>

<button class="settings-toggle" id="settingsButton">
    ⚙️ Settings
</button>

<div class="settings-panel" id="settingsPanel">
    <div class="settings-header">
        <h3>Game Settings</h3>
        <button class="close-settings" id="closeSettings">×</button>
    </div>

    <div class="setting-group">
        <label for="targetCount">Target Count: <span id="countDisplay">1 target</span></label>
        <input type="range" id="targetCount" min="1" max="10" value="1" onchange="updateTargetCount(this.value)">
    </div>

    <div class="setting-group">
        <label for="objectType">Object Type:</label>
        <select id="objectType" onchange="updateObjectType(this.value)">
            <option value="dot">Dot</option>
            <option value="mouse">Mouse Emoji</option>
            <option value="worm">Worm</option>
        </select>
    </div>

    <div class="setting-group worm-only">
        <label for="wormLength">Worm Length: <span id="lengthDisplay">5 segments</span></label>
        <input type="range" id="wormLength" min="3" max="15" value="5" onchange="updateWormLength(this.value)">
    </div>

    <div class="setting-group">
        <label for="movementType">Movement Pattern:</label>
        <select id="movementType" onchange="updateMovementType(this.value)">
            <option value="random">Random</option>
            <option value="circular">Circular</option>
            <option value="zigzag">Zigzag</option>
            <option value="edges">Around Edges</option>
            <option value="spiral">Spiral</option>
            <option value="mouse">Mouse Control</option>
        </select>
    </div>

    <div class="setting-group">
        <label for="movementSpeed">Movement Speed: <span id="speedDisplay">2.0s</span></label>
        <input type="range" id="movementSpeed" min="100" max="5000" value="2000" onchange="updateSpeed(this.value)">
    </div>

    <div class="setting-group random-only">
        <label for="idleTime">Idle Time: <span id="idleDisplay">1.0s</span></label>
        <input type="range" id="idleTime" min="0" max="5000" value="1000" onchange="updateIdleTime(this.value)">
    </div>

    <div class="setting-group">
        <label for="targetSize">Target Size: <span id="sizeDisplay">20px</span></label>
        <input type="range" id="targetSize" min="10" max="100" value="20" onchange="updateTargetSize(this.value)">
    </div>

    <div class="setting-group">
        <label for="targetColor">Target Color:</label>
        <input type="color" id="targetColor" value="#ff0000" onchange="updateTargetColor(this.value)">
    </div>

    <div class="setting-group">
        <label for="backgroundColor">Background Color:</label>
        <input type="color" id="backgroundColor" value="#000000" onchange="updateBackgroundColor(this.value)">
    </div>
</div>

<script>
    // Game settings
    let settings = {
        targetCount: 1,
        objectType: 'dot',
        movementType: 'random',
        speed: 2000,
        idleTime: 1000,
        targetSize: 20,
        targetColor: '#ff0000',
        backgroundColor: '#000000',
        wormLength: 5
    };

    // Game state
    let targets = [];
    let targetStates = [];
    let isMoving = true;
    let animationFrameId = null;
    let wormAnimationId = null;
    let mousePosition = { x: 0, y: 0 };
    let lastTap = 0;
    let randomMovementTimeouts = [];

    // UI elements
    const settingsPanel = document.getElementById('settingsPanel');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const gameStatus = document.getElementById('gameStatus');

    function createTarget(index) {
        const target = document.createElement('div');
        target.className = 'target';
        target.id = `target-${index}`;

        const x = Math.random() * (window.innerWidth - settings.targetSize);
        const y = Math.random() * (window.innerHeight - settings.targetSize);

        target.style.left = x + 'px';
        target.style.top = y + 'px';
        target.style.width = settings.targetSize + 'px';
        target.style.height = settings.targetSize + 'px';
        target.style.position = 'absolute';
        target.style.borderRadius = '50%';
        target.style.backgroundColor = settings.targetColor;
        target.style.boxShadow = `0 0 ${settings.targetSize * 0.5}px ${settings.targetColor}`;

        document.body.appendChild(target);
        return target;
    }

    function initializeTargetStates() {
        targetStates = [];
        for (let i = 0; i < settings.targetCount; i++) {
            targetStates.push({
                lastMoveTime: performance.now(),
                isIdle: false,
                idleStartTime: 0,
                orbitalAngle: Math.random() * Math.PI * 2,
                waveProgress: Math.random(),
                edgeProgress: Math.random() * (2 * (window.innerWidth + window.innerHeight)),
                spiralAngle: 0,
                spiralRadius: 50,
                wormSegments: [],
                wormTarget: { x: 0, y: 0 },
                centerX: window.innerWidth / 2,
                centerY: window.innerHeight / 2
            });
        }
    }

    function clearWormSegments(state) {
        if (state.wormSegments) {
            state.wormSegments.forEach(segment => {
                if (segment.element && segment.element.parentNode) {
                    segment.element.parentNode.removeChild(segment.element);
                }
            });
            state.wormSegments = [];
        }
    }

    function initializeWorm(targetIndex) {
        const state = targetStates[targetIndex];
        const target = targets[targetIndex];

        clearWormSegments(state);

        const targetRect = target.getBoundingClientRect();
        const centerX = targetRect.left + targetRect.width / 2;
        const centerY = targetRect.top + targetRect.height / 2;

        state.wormTarget.x = centerX;
        state.wormTarget.y = centerY;

        for (let i = 0; i < settings.wormLength; i++) {
            const segment = document.createElement('div');
            segment.className = 'worm-segment';

            const size = Math.max(8, settings.targetSize * (1 - i * 0.1));
            const x = centerX - (i * settings.targetSize * 0.8);
            const y = centerY;

            segment.style.position = 'absolute';
            segment.style.width = size + 'px';
            segment.style.height = size + 'px';
            segment.style.borderRadius = '50%';
            segment.style.backgroundColor = settings.targetColor;
            segment.style.boxShadow = `0 0 ${size * 0.3}px ${settings.targetColor}`;
            segment.style.left = (x - size/2) + 'px';
            segment.style.top = (y - size/2) + 'px';
            segment.style.zIndex = '1000';

            document.body.appendChild(segment);

            state.wormSegments.push({
                element: segment,
                x: x,
                y: y,
                targetX: x,
                targetY: y
            });
        }
    }

    function updateWormPhysics(state) {
        if (!state.wormSegments || state.wormSegments.length === 0) return;

        for (let i = 0; i < state.wormSegments.length; i++) {
            const segment = state.wormSegments[i];

            if (i === 0) {
                segment.targetX = state.wormTarget.x;
                segment.targetY = state.wormTarget.y;
            } else {
                const prevSegment = state.wormSegments[i - 1];
                const distance = settings.targetSize * 0.8;

                const dx = prevSegment.x - segment.x;
                const dy = prevSegment.y - segment.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > distance) {
                    segment.targetX = prevSegment.x - (dx / dist) * distance;
                    segment.targetY = prevSegment.y - (dy / dist) * distance;
                }
            }

            segment.x += (segment.targetX - segment.x) * 0.1;
            segment.y += (segment.targetY - segment.y) * 0.1;

            const size = parseFloat(segment.element.style.width);
            segment.element.style.left = (segment.x - size/2) + 'px';
            segment.element.style.top = (segment.y - size/2) + 'px';
        }
    }

    function wormAnimationLoop() {
        if (settings.objectType === 'worm' && isMoving) {
            targetStates.forEach(state => updateWormPhysics(state));
        }
        wormAnimationId = requestAnimationFrame(wormAnimationLoop);
    }

    function updateTransitionModes() {
        const speedInSeconds = settings.speed / 1000;

        targets.forEach(target => {
            if (settings.movementType === 'random') {
                target.style.transition = `left ${speedInSeconds}s ease-in-out, top ${speedInSeconds}s ease-in-out`;
            } else if (settings.movementType === 'mouse') {
                target.style.transition = 'left 0.1s ease-out, top 0.1s ease-out';
            } else {
                target.style.transition = 'left 0.05s ease-out, top 0.05s ease-out';
            }
        });
    }

    function getNextPosition(targetIndex, currentTime) {
        const state = targetStates[targetIndex];

        const maxX = window.innerWidth - settings.targetSize;
        const maxY = window.innerHeight - settings.targetSize;

        const speedMultiplier = (3000 / settings.speed);

        switch (settings.movementType) {
            case 'random':
                return {
                    x: Math.random() * maxX,
                    y: Math.random() * maxY
                };

            case 'circular':
                const radius = Math.min(maxX, maxY) / 3;
                state.orbitalAngle += 0.02 * speedMultiplier;
                return {
                    x: state.centerX + radius * Math.cos(state.orbitalAngle) - settings.targetSize / 2,
                    y: state.centerY + radius * Math.sin(state.orbitalAngle) - settings.targetSize / 2
                };

            case 'zigzag':
                state.waveProgress += 0.02 * speedMultiplier;
                return {
                    x: (state.waveProgress % 2) * maxX,
                    y: Math.abs(Math.sin(state.waveProgress * Math.PI)) * maxY
                };

            case 'edges':
                const perimeter = 2 * (maxX + maxY);
                state.edgeProgress += (perimeter / 200) * speedMultiplier;
                state.edgeProgress = state.edgeProgress % perimeter;

                if (state.edgeProgress < maxX) {
                    return { x: state.edgeProgress, y: 0 };
                } else if (state.edgeProgress < maxX + maxY) {
                    return { x: maxX, y: state.edgeProgress - maxX };
                } else if (state.edgeProgress < 2 * maxX + maxY) {
                    return { x: maxX - (state.edgeProgress - maxX - maxY), y: maxY };
                } else {
                    return { x: 0, y: maxY - (state.edgeProgress - 2 * maxX - maxY) };
                }

            case 'spiral':
                state.spiralAngle += 0.1 * speedMultiplier;
                state.spiralRadius += 0.5 * speedMultiplier;
                if (state.spiralRadius > Math.min(maxX, maxY) / 2) {
                    state.spiralRadius = 50;
                }
                return {
                    x: state.centerX + state.spiralRadius * Math.cos(state.spiralAngle) - settings.targetSize / 2,
                    y: state.centerY + state.spiralRadius * Math.sin(state.spiralAngle) - settings.targetSize / 2
                };

            case 'mouse':
                return {
                    x: Math.max(0, Math.min(maxX, mousePosition.x - settings.targetSize / 2)),
                    y: Math.max(0, Math.min(maxY, mousePosition.y - settings.targetSize / 2))
                };

            default:
                return { x: Math.random() * maxX, y: Math.random() * maxY };
        }
    }

    function scheduleRandomMovement(targetIndex) {
        const moveToNewPosition = () => {
            if (!isMoving || settings.movementType !== 'random') return;

            const target = targets[targetIndex];
            const state = targetStates[targetIndex];

            // Ensure smooth transitions for random movement
            const speedInSeconds = settings.speed / 1000;
            target.style.transition = `left ${speedInSeconds}s ease-in-out, top ${speedInSeconds}s ease-in-out`;

            // Move to new position
            const newPos = getNextPosition(targetIndex, performance.now());

            if (settings.objectType === 'worm' && state.wormSegments) {
                state.wormTarget.x = newPos.x + settings.targetSize / 2;
                state.wormTarget.y = newPos.y + settings.targetSize / 2;
            } else {
                target.style.left = newPos.x + 'px';
                target.style.top = newPos.y + 'px';
            }

            // Schedule next movement
            // If idle time is 0, move immediately after animation finishes
            const nextMoveDelay = settings.speed + settings.idleTime;
            randomMovementTimeouts[targetIndex] = setTimeout(() => {
                scheduleRandomMovement(targetIndex);
            }, nextMoveDelay);
        };

        moveToNewPosition();
    }

    function animate() {
        if (!isMoving) return;

        const currentTime = performance.now();

        for (let i = 0; i < targets.length; i++) {
            const target = targets[i];
            const state = targetStates[i];

            if (settings.movementType === 'random') continue;

            const newPos = getNextPosition(i, currentTime);

            if (settings.objectType === 'worm' && state.wormSegments) {
                state.wormTarget.x = newPos.x + settings.targetSize / 2;
                state.wormTarget.y = newPos.y + settings.targetSize / 2;
            } else {
                target.style.left = newPos.x + 'px';
                target.style.top = newPos.y + 'px';
            }

            state.lastMoveTime = currentTime;
        }

        animationFrameId = requestAnimationFrame(animate);
    }

    function restartMovement() {
        randomMovementTimeouts.forEach(timeout => clearTimeout(timeout));
        randomMovementTimeouts = [];
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }

        if (!isMoving) return;

        updateTransitionModes();

        targetStates.forEach(state => {
            state.lastMoveTime = performance.now();
            state.isIdle = false;
            state.idleStartTime = 0;
        });

        if (settings.movementType === 'random') {
            for (let i = 0; i < targets.length; i++) {
                scheduleRandomMovement(i);
            }
        } else {
            animate();
        }
    }

    function updateCursorVisibility() {
        const isSettingsOpen = settingsPanel.classList.contains('visible');
        if (isSettingsOpen || !isMoving) {
            document.body.className = 'game-paused';
        } else {
            document.body.className = 'game-running';
        }
    }

    function toggleSettings() {
        settingsPanel.classList.toggle('visible');
        updateCursorVisibility();
    }

    function togglePause() {
        isMoving = !isMoving;
        gameStatus.textContent = isMoving ? 'Game Running' : 'Game Paused';

        if (isMoving) {
            pauseOverlay.classList.remove('visible');
            restartMovement();
        } else {
            pauseOverlay.classList.add('visible');
            randomMovementTimeouts.forEach(timeout => clearTimeout(timeout));
            randomMovementTimeouts = [];
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }

        updateCursorVisibility();
    }

    function updateAllTargetAppearance() {
        targets.forEach((target, i) => {
            target.style.width = settings.targetSize + 'px';
            target.style.height = settings.targetSize + 'px';

            if (settings.objectType === 'mouse') {
                target.style.borderRadius = '0';
                target.innerHTML = '🐭';
                target.style.display = 'flex';
                target.style.alignItems = 'center';
                target.style.justifyContent = 'center';
                target.style.fontSize = settings.targetSize + 'px';
                target.style.backgroundColor = 'transparent';
                target.style.boxShadow = 'none';
                clearWormSegments(targetStates[i]);
            } else if (settings.objectType === 'worm') {
                target.style.display = 'none';

                if (targetStates[i] && targetStates[i].wormSegments) {
                    targetStates[i].wormSegments.forEach((segment, j) => {
                        const size = Math.max(8, settings.targetSize * (1 - j * 0.1));
                        segment.element.style.width = size + 'px';
                        segment.element.style.height = size + 'px';
                        segment.element.style.backgroundColor = settings.targetColor;
                        segment.element.style.boxShadow = `0 0 ${size * 0.3}px ${settings.targetColor}`;
                    });
                }
            } else {
                target.style.borderRadius = '50%';
                target.innerHTML = '';
                target.style.display = 'block';
                target.style.backgroundColor = settings.targetColor;
                target.style.boxShadow = `0 0 ${settings.targetSize * 0.5}px ${settings.targetColor}`;
                clearWormSegments(targetStates[i]);
            }
        });
    }

    function updateTargetCount(value) {
        const newCount = parseInt(value);
        settings.targetCount = newCount;
        document.getElementById('countDisplay').textContent = newCount + (newCount === 1 ? ' target' : ' targets');

        targets.forEach(target => {
            if (target.parentNode) {
                target.parentNode.removeChild(target);
            }
        });

        targetStates.forEach(state => {
            clearWormSegments(state);
        });

        targets = [];
        targetStates = [];
        initializeTargetStates();

        for (let i = 0; i < settings.targetCount; i++) {
            targets.push(createTarget(i));

            if (settings.objectType === 'worm') {
                initializeWorm(i);
            }
        }

        updateAllTargetAppearance();
        restartMovement();
    }

    function updateObjectType(value) {
        settings.objectType = value;

        targetStates.forEach(state => {
            clearWormSegments(state);
        });

        const wormSettings = document.querySelectorAll('.worm-only');
        wormSettings.forEach(setting => {
            setting.style.display = value === 'worm' ? 'block' : 'none';
        });

        if (settings.objectType === 'worm') {
            targets.forEach((target, i) => {
                initializeWorm(i);
            });
        }

        updateAllTargetAppearance();
        restartMovement();
    }

    function updateWormLength(value) {
        const newLength = parseInt(value);
        settings.wormLength = newLength;
        document.getElementById('lengthDisplay').textContent = newLength + ' segments';

        if (settings.objectType === 'worm') {
            targets.forEach((target, i) => {
                clearWormSegments(targetStates[i]);
                initializeWorm(i);
            });
        }

        updateAllTargetAppearance();
        restartMovement();
    }

    function updateMovementType(value) {
        settings.movementType = value;

        const randomSettings = document.querySelectorAll('.random-only');
        randomSettings.forEach(setting => {
            setting.style.display = value === 'random' ? 'block' : 'none';
        });

        restartMovement();
    }

    function updateSpeed(value) {
        const speedInMs = parseInt(value);
        settings.speed = speedInMs;
        document.getElementById('speedDisplay').textContent = (speedInMs / 1000).toFixed(1) + 's';
        updateTransitionModes();
        restartMovement();
    }

    function updateIdleTime(value) {
        const idleInMs = parseInt(value);
        settings.idleTime = idleInMs;
        document.getElementById('idleDisplay').textContent = (idleInMs / 1000).toFixed(1) + 's';
        restartMovement();
    }

    function updateTargetSize(value) {
        const newSize = parseInt(value);
        settings.targetSize = newSize;
        document.getElementById('sizeDisplay').textContent = newSize + 'px';
        updateAllTargetAppearance();
    }

    function updateTargetColor(value) {
        settings.targetColor = value;
        updateAllTargetAppearance();
    }

    function updateBackgroundColor(value) {
        settings.backgroundColor = value;
        document.body.style.backgroundColor = value;
    }

    // Event listeners
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            togglePause();
        } else if (e.code === 'KeyS') {
            e.preventDefault();
            toggleSettings();
        }
    });

    document.addEventListener('mousemove', (e) => {
        mousePosition.x = e.clientX;
        mousePosition.y = e.clientY;
    });

    document.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length > 0) {
            mousePosition.x = e.touches[0].clientX;
            mousePosition.y = e.touches[0].clientY;
        }
    });

    document.addEventListener('touchstart', (e) => {
        const now = new Date().getTime();
        const timeSince = now - lastTap;
        if (timeSince < 300 && timeSince > 0) {
            e.preventDefault();
            togglePause();
        }
        lastTap = now;
    });

    document.getElementById('settingsButton').addEventListener('click', toggleSettings);
    document.getElementById('closeSettings').addEventListener('click', toggleSettings);

    document.addEventListener('click', (e) => {
        if (!settingsPanel.contains(e.target) &&
            !document.getElementById('settingsButton').contains(e.target) &&
            settingsPanel.classList.contains('visible')) {
            toggleSettings();
        }
    });

    // Initialize game
    function init() {
        initializeTargetStates();

        for (let i = 0; i < settings.targetCount; i++) {
            targets.push(createTarget(i));
            if (settings.objectType === 'worm') {
                initializeWorm(i);
            }
        }

        updateAllTargetAppearance();
        updateTransitionModes();
        restartMovement();
        wormAnimationLoop();

        // Set initial UI values
        document.getElementById('countDisplay').textContent = settings.targetCount + (settings.targetCount === 1 ? ' target' : ' targets');
        document.getElementById('speedDisplay').textContent = (settings.speed / 1000).toFixed(1) + 's';
        document.getElementById('idleDisplay').textContent = (settings.idleTime / 1000).toFixed(1) + 's';
        document.getElementById('sizeDisplay').textContent = settings.targetSize + 'px';
        document.getElementById('lengthDisplay').textContent = settings.wormLength + ' segments';

        // Show/hide movement type specific settings
        const randomSettings = document.querySelectorAll('.random-only');
        const wormSettings = document.querySelectorAll('.worm-only');

        randomSettings.forEach(setting => {
            setting.style.display = settings.movementType === 'random' ? 'block' : 'none';
        });

        wormSettings.forEach(setting => {
            setting.style.display = settings.objectType === 'worm' ? 'block' : 'none';
        });
    }

    // Start the game when page loads
    window.addEventListener('load', init);
</script>
</body>
</html>